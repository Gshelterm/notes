**《Java后端技术面试汇总》**

作 者： *Java后端技术 微信公众号*

完成日期： *20180729*

| 版本号 | 修改情况 | 修改人 | 修改日期 |
|--------|----------|--------|----------|
| v1.0   |          |        |          |
| v2.0   |          |        |          |
| v3.0   |          |        |          |
| v4.0   |          |        |          |
| v5.0   |          |        |          |

![F:\\公众号\\文章底部二维码.jpg](media/5e670f006e5f2820e2d355f2e15a3407.jpg)

一、Java面试通关秘籍第一套
==========================

**1、基础篇**
-------------

### **1.1、Java基础 **

-   面向对象的特征：继承、封装和多态

-   final, finally, finalize 的区别

-   Exception、Error、运行时异常与一般异常有何异同

-   请写出5种常见到的runtime exception

-   int 和 Integer 有什么区别，Integer的值缓存范围
int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况.
在 Java 5 中，为 Integer 的操作引入了一个新的特性，用来节省内存和提高性能。整型对象在内部实现中通过使用相同的对象引用实现了缓存和重用。
在创建新的 Integer 对象之前会先在 IntegerCache.cache 中查找。有一个专门的 Java 类来负责 Integer 的缓存。这个类是用来实现缓存支持，并支持 -128 到 127 之间的自动装箱过程。最大值 127 可以通过 JVM 的启动参数 -XX:AutoBoxCacheMax=size 修改。 缓存通过一个 for 循环实现。从小到大的创建尽可能多的整数并存储在一个名为 cache 的整数数组中。
实际上在 Java 5 中引入这个特性的时候，范围是固定的 -128 至 +127。后来在 Java 6 中，最大值映射到 java.lang.Integer.IntegerCache.high，可以使用 JVM 的启动参数设置最大值。
```java
    public static void main(String[] args) {  
        Integer i1 = 127;  
        Integer i2 = 127;  
        System.err.println(i1 == i2);  
          
        i1 = 128;  
        i2 = 128;  
        System.err.println(i1 == i2);  
    }  
```
输出true, false;
JVM会自动维护八种基本类型的常量池，int常量池中初始化-128~127的范围，所以当为Integer i=127时，在自动装箱过程中是取自常量池中的数值，而当Integer i=128时，128不在常量池范围内，所以在自动装箱过程中需new 128，所以地址不一样。

-   包装类，装箱和拆箱

-   String、StringBuilder、StringBuffer

-   重载和重写的区别

重载Overloading：函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。
重写Override:Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。
重载是一个编译期概念、重写是一个运行期间概念。
重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。
重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法。
因为在编译期已经确定调用哪个方法，所以重载并不是多态。而重写是多态。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象也无关。

-   抽象类和接口有什么区别

-   说说反射的用途及实现

-   说说自定义注解的场景及实现

-   HTTP请求的GET与POST方式的区别

-   Session与Cookie区别

-   列出自己常用的JDK包

-   MVC设计思想

-   equals与==的区别

-   hashCode和equals方法的区别与联系

-   什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable接口的作用

-   Object类中常见的方法，为什么wait  notify会放在Object里边？

为什么wait  notify会放在Object里边：https://stackoverflow.com/questions/17840397/concept-behind-putting-wait-notify-methods-in-object-class#
wait()在特定的Obejct实例上-监视器monitor被赋予的对象更合适。想给等待在这个Object实例的线程发送信号使用notify().notifyAll()通知所有所有线程。
如果wait、notify在Thread里，那么每个线程需要知道其他线程的状态。线程1怎么知道线程2在访问特定的资源，如果线程1需要调用thread2.notify(),它需要通过某种方法知道线程2在等待。这就需要某些机制使线程登记它们需要的资源和动作，所以其他线程才能够signal它们，当资源准备好或可用的时候。
Java里，Object本身是被所有线程共享的实体，这允许它们彼此交流。线程没有对彼此的具体认知所以它们可用异步的执行。They run and they lock, wait, and notify on the object that they want to get access to. 线程对彼此没有认知并且不需要知道他们的状态。它们不需要知道线程2在等待资源--它们只通知资源并且等待资源的线程会被通知。
在Java里，我们使用lock obects作为synchronization, mutex, and communication points between threads.我们在锁对象上同步以获得互斥访问和同步内存。等待在对象上如果我们等待某些条件改变。
```java
// locks should be final objects so the object instance we are synchronizing on,
// never changes
private final Object lock = new Object();
...
// ensure that the thread has a mutex lock on some key code
synchronized (lock) {
    ...
    // i need to wait for other threads to finish with some resource
    // this releases the lock and waits on the associated monitor
    lock.wait();
    ...
    // i need to signal another thread that some state has changed and they can
    // awake and continue to run
    lock.notify();
}
```
程序里可以有任意数量的锁对象，每个用来锁定特定资源和代码块。
这可以让你可规划程序里的线程的数量，增多或减少。锁对象确保线程间互斥和通信与运行线程的数量是独立的。

-   Java的平台无关性如何体现出来的

-   JDK和JRE的区别

-   Java 8有哪些新特性

### **1.2、Java常见集合**

-   List 和 Set 区别

-   Set和hashCode以及equals方法的联系

-   List 和 Map 区别

-   Arraylist 与 LinkedList 区别

-   ArrayList 与 Vector 区别

-   HashMap 和 Hashtable 的区别

-   HashSet 和 HashMap 区别

-   HashMap 和 ConcurrentHashMap 的区别

-   HashMap 的工作原理及代码实现，什么时候用到红黑树

-   多线程情况下HashMap死循环的问题

参见:https://coolshell.cn/articles/9606.html
JDK1.7的HashMap扩容时候，将元素转移到新链表时是对节点在头部插入，桶的顺序会相反
在多线程环境下
Entry<K,V> next = e.next;
e.next = newTable[i];
newTable[i] = e;
e = next;
的糟糕情况下的切换会造成死循环，图见链接
```java
void transfer(Entry[] newTable)
{
    Entry[] src = table;
    int newCapacity = newTable.length;
    //下面这段代码的意思是：
    //  从OldTable里摘一个元素出来，然后放到NewTable中
    for (int j = 0; j < src.length; j++) {
        Entry<K,V> e = src[j];
        if (e != null) {
            src[j] = null;
            do {
                Entry<K,V> next = e.next;
                int i = indexFor(e.hash, newCapacity);
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            } while (e != null);
        }
    }
}
```
JDK1.8：扩容后，新数组中的链表顺序依然与旧数组中的链表顺序保持一致！
https://my.oschina.net/liuxiaomian/blog/848996

-   HashMap出现Hash DOS攻击的问题

-   ConcurrentHashMap 的工作原理及代码实现，如何统计所有的元素个数

-   手写简单的HashMap

-   看过那些Java集合类的源码

**1.3、进程和线程**

-   线程和进程的概念、并行和并发的概念

-   创建线程的方式及实现

1. 继承Thread类创建线程类：
    1. 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。
    2. 创建Thread子类的实例，即创建了线程对象。
    3. 调用线程对象的start()方法来启动该线程。
2. 通过Runnable接口创建线程类：
    1. 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。
    2. 创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。
    3. 调用线程对象的start()方法来启动该线程。
3. 通过Callable和Future创建线程：
    1. 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。
    2. 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。
    3. 使用FutureTask对象作为Thread对象的target创建并启动新线程。
    4. 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值
4. 采用实现Runnable、Callable接口的方式创见多线程时，优势是：线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。  劣势: 编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。
5. 使用继承Thread类的方式创建多线程时优势是：编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。劣势是：线程类已经继承了Thread类，所以不能再继承其他父类。

-   进程间通信的方式

1. 管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。
2. 命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关 系 进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。
3. 信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送 信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction
4. 消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺.
5. 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
6. 内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。
7. 信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。
8. 套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。

-   说说 CountDownLatch、CyclicBarrier 原理和区别

-   说说 Semaphore 原理

-   说说 Exchanger 原理

-   ThreadLocal 原理分析，ThreadLocal为什么会出现OOM，出现的深层次原理

ThreadLocal可以保证每个线程拥有一个变量的副本，实现了线程隔离,主要利用了每个Thread有个ThreadLocalMap,ThreadLocalMap保存了该线程拥有的所有ThreadLocal对象，并利用弱引用机制避免了Map无线增大导致内存泄露的问题。

-   讲讲线程池的实现原理

https://www.jianshu.com/p/87bff5cc8d8c
ctl
excute()方法
addworker()方法

-   线程池的几种实现方式

-   线程的生命周期，状态是如何转移的



-   可参考：《*Java多线程编程核心技术*》

### **1.4、锁机制**

-   说说线程安全问题，什么是线程安全，如何保证线程安全

-   重入锁的概念，重入锁为什么可以防止死锁

-   产生死锁的四个条件（互斥、请求与保持、不剥夺、循环等待）

ostep:
+ Mutual exclusion: Threads claim exclusive control of resources that they require (e.g., a thread grabs a lock).
+ Hold-and-wait: Threads hold resources allocated to them (e.g., locks that they have already acquired) while waiting for additional resources (e.g., locks that they wish to acquire)
+ No preemption: Resources (e.g., locks) cannot be forcibly removed from threads that are holding them.
+ Circular wait: There exists a circular chain of threads such that each thread holds one or more resources (e.g., locks) that are being requested by the next thread in the chain.

If any of these four conditions are not met, deadlock cannot occur.

-   如何检查死锁（通过jConsole检查死锁）

-   volatile 实现原理（禁止指令重排、刷新内存）

-   synchronized 实现原理（对象监视器）

-   synchronized 与 lock 的区别

-   AQS同步队列

-   CAS无锁的概念、乐观锁和悲观锁

-   常见的原子操作类

-   什么是ABA问题，出现ABA问题JDK是如何解决的

CAS导致ABA问题：A->B->A
在运用CAS做Lock-Free操作中有一个经典的ABA问题：
线程1准备用CAS将变量的值由A替换为B，在此之前，线程2将变量的值由A替换为C，又由C替换为A，然后线程1执行CAS时发现变量的值仍然为A，所以CAS成功。但实际上这时的现场已经和最初不同了，尽管CAS成功，但可能存在潜藏的问题，例如下面的例子：
现有一个用单向链表实现的堆栈，栈顶为A，这时线程T1已经知道A.next为B，然后希望用CAS将栈顶替换为B：
head.compareAndSet(A,B);
在T1执行上面这条指令之前，线程T2介入，将A、B出栈，再pushD、C、A，此时堆栈结构如下图，而对象B此时处于游离状态：
此时轮到线程T1执行CAS操作，检测发现栈顶仍为A，所以CAS成功，栈顶变为B，但实际上B.next为null，所以此时的情况变为：
其中堆栈中只有B一个元素，C和D组成的链表不再存在于堆栈中，平白无故就把C、D丢掉了。

各种乐观锁的实现中通常都会用版本戳version来对记录或对象标记，避免并发操作带来的问题: AtomicStampedReference<E>，它通过包装[E,Integer]的元组来对对象标记版本戳stamp，从而避免ABA问题

-   乐观锁的业务场景及实现方式

-   Java 8并法包下常见的并发类

-   偏向锁、轻量级锁、重量级锁、自旋锁的概念

-   可参考：《[Java多线程编程核心技术](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247484881&idx=2&sn=b0ecf85cd7c9e543c84e7a9859c20a26&chksm=e9c5fc60deb27576a6a9c453dabc585f43d9f29fd8a8f37ed0e7cc2f012c86b23fbd21763a39&scene=21#wechat_redirect)》

### **1.5、JVM**

-   JVM运行时内存区域划分

-   内存溢出OOM和堆栈溢出SOE的示例及原因、如何排查与解决

-   如何判断对象是否可以回收或存活

-   常见的GC回收算法及其含义

-   常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等

-   JVM如何设置参数

-   JVM性能调优

-   类加载器、双亲委派模型、一个类的生命周期、类是如何加载到JVM中的

两个类相等：类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。
类加载器分类， 从虚拟机角度：
+ 启动类加载器（Bootstrap ClassLoader），这个类加载器用 C++ 实现，是虚拟机自身的一部分；
+ 所有其他类的加载器，这些类由 Java 实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。

从Java 开发人员的角度看:
+ 启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 <JRE_HOME>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。
+ 扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 <JAVA_HOME>/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。
+ 应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
  
双亲委派模型:
该模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现。
1. 工作过程：
    一个类加载器首先将类加载请求传送到父类加载器，只有当父类加载器无法完成类加载请求时才尝试加载。
2. 作用:
   使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。
3. 实现:
   抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。

-   类加载的过程：加载、验证、准备、解析、初始化

1. 加载:
+ 通过一个类的全限定名来获取定义此类的二进制字节流。
+ 将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。
+ 在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。

2. 验证： 确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
+ 文件格式验证：验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。
+ 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。
+ 字节码验证：通过数据流和控制流分析，确保程序语义是合法、符合逻辑的。
+ 符号引用验证：发生在虚拟机将符号引用转换为直接引用的时候，对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。

3. 准备
+ 类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。
+ 实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在 Java 堆中。（实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次）
+ 如果类变量是常量，那么会按照表达式来进行初始化，而不是赋值为 0。

4. 解析
+ 将常量池的符号引用替换为直接引用的过程。

5. 初始化
+ 初始化阶段才真正开始执行类中的定义的 Java 程序代码。初始化阶段即虚拟机执行类构造器 &lt;clinit&gt;() 方法的过程。
+ 在准备阶段，**类变量**已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。
+ &lt;clinit&gt;() 特点:
   + 是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。
   + 与类的构造函数（或者说实例构造器&lt;linit&gt;()）不同，不需要显式的调用父类的构造器。虚拟机会自动保证在子类的 &lt;clinit&gt;() 方法运行之前，父类的 &lt;clinit&gt;() 方法已经执行结束。因此虚拟机中第一个执行&lt;clinit&gt;() 方法的类肯定为 java.lang.Object。
   + 由于父类的 &lt;clinit&gt;() 方法先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作。
   + &lt;clinit&gt;() 方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成&lt;clinit&gt;() 方法。
   + 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit&gt;() 方法。不同略。
   + 虚拟机会保证一个类的&lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的&lt;clinit&gt;() 方法，其它线程都会阻塞等待，直到活动线程执行&lt;clinit&gt;() 方法完毕。如果在一个类的&lt;clinit&gt;() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。 -> 用静态变量和方法实现单例模式。

-   强引用、软引用、弱引用、虚引用

-   Java内存模型JMM

-   TLAB

+ Thread Local Allocation Buffer.即线程本地分配缓存区，这是一个线程专用的内存分配区域。 
+ 提高效率： JVM在内存新生代Eden Space中开辟了一小块线程私有的区域，称作TLAB（Thread-local allocation buffer）。默认设定为占用Eden Space的1%。在Java程序中很多对象都是小对象且用过即丢，它们不存在线程共享也适合被快速GC，所以对于小对象通常JVM会优先分配在TLAB上，并且TLAB上的分配由于是线程私有所以没有锁开销。因此在实践中分配多个小对象的效率通常比分配一个大对象的效率要高。
也就是说，Java中每个线程都会有自己的缓冲区称作TLAB（Thread-local allocation buffer），每个TLAB都只有一个线程可以操作，TLAB结合bump-the-pointer技术可以实现快速的对象分配，而不需要任何的锁进行同步，也就是说，在对象分配的时候不用锁住整个堆，而只需要在自己的缓冲区分配即可。
+ 避免线程冲突：由于对象一般会分配在堆上，而堆是全局共享的。因此在同一时间，可能会有多个线程在堆上申请空间。因此，每次对象分配都必须要进行同步（虚拟机采用CAS配上失败重试的方式保证更新操作的原子性），而在竞争激烈的场合分配的效率又会进一步下降。JVM使用TLAB来避免多线程冲突，在给对象分配内存时，每个线程使用自己的TLAB，这样可以避免线程同步，提高了对象分配的效率。
+ 当一个Java线程在自己的TLAB中分配到尽头之后，再要分配就会出发一次“TLAB refill”，也就是说之前自己的TLAB就“不管了”（所有权交回给共享的Eden），然后重新从Eden里分配一块空间作为新的TLAB。通常情况下，在TLAB中分配多次才会填满TLAB、触发TLAB refill，这样使用TLAB分配就比直接从共享部分的Eden分配要均摊（amortized）了同步开销，于是提高了性能。

-   对象分配的过程

    1. 编译器通过逃逸分析，确定对象是在栈上分配还是在堆上分配。如果是在堆上分配，则进入选项2.
    2. 如果tlab_top + size <= tlab_end，则在在TLAB上直接分配对象并增加tlab_top 的值，如果现有的TLAB不足以存放当前对象则3.
    3. 重新申请一个TLAB，并再次尝试存放当前对象。如果放不下，则4.
    4. 在Eden区加锁（这个区是多线程共享的），如果eden_top + size <= eden_end则将对象存放在Eden区，增加eden_top 的值，如果Eden区不足以存放，则5.
    5. 执行一次Young GC（minor collection）。
    6. 经过Young GC之后，如果Eden区任然不足以存放当前对象，则直接分配到老年代。

### **1.6、设计模式**

-   常见的设计模式

-   设计模式的的六大原则及其含义

-   常见的单例模式以及各种实现方式的优缺点，哪一种最好，手写常见的单利模式

-   设计模式在实际场景中的应用

-   Spring中用到了哪些设计模式

工厂模式，策略模式，构建者模式，解释器模式

-   MyBatis中用到了哪些设计模式

-   你项目中有使用哪些设计模式

-   说说常用开源框架中设计模式使用分析

-   动态代理很重要！！！

**1.7、数据结构**

-   树（二叉查找树、平衡二叉树、红黑树、B树、B+树）

-   深度优先算法、广度优先算法

-   克鲁斯卡尔算法、普林母算法、迪克拉斯算法

-   什么是一致性Hash及其原理、Hash环问题

主要用于分布式缓存。
wiki: 一致哈希 是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K / n 个关键字重新映射，其中K是关键字的数量， n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。 
在使用n台缓存服务器时，一种常用的负载均衡方式是，对资源o的请求使用 hash (o) = o mod n来映射到某一台缓存服务器。当增加或减少一台缓存服务器时这种方式可能会改变所有资源对应的hash值，也就是所有的缓存都失效了，这会使得缓存服务器大量集中地向原始内容服务器更新缓存。因此需要一致哈希算法来避免这样的问题。 一致哈希尽可能使同一个资源映射到同一台缓存服务器。这种方式要求增加一台缓存服务器时，新的服务器尽量分担存储其他所有服务器的缓存资源。减少一台缓存服务器时，其他所有服务器也可以尽量分担存储它的缓存资源。 一致哈希算法的主要思想是将每个缓存服务器与一个或多个哈希值域区间关联起来，其中区间边界通过计算缓存服务器对应的哈希值来决定。（定义区间的哈希函数不一定和计算缓存服务器哈希值的函数相同，但是两个函数的返回值的范围需要匹配。）如果一个缓存服务器被移除，则它所对应的区间会被并入到邻近的区间，其他的缓存服务器不需要任何改变。
实现: https://blog.csdn.net/lihao21/article/details/54193868

hash环可能产生负载不均衡的问题：缓存倾斜性
引入虚拟节点解决：将每台物理机器虚拟为一组虚拟机器，将虚拟机器放置到hash环上，如果需要确定对象的机器，先确定对象的虚拟机器，再由虚拟机器确定物理机器。虚拟节点均匀的分散在hash环上。

-   常见的排序算法和查找算法：快排、折半查找、堆排序等

### **1.8、网络/IO基础**

-   BIO、NIO、AIO的概念

-   什么是长连接和短连接

HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。

在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。
但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码： 
Connection:keep-alive
在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间。

-   Http1.0和2.0相比有什么区别，可参考《*Http 2.0*》

-   Https的基本概念

    + HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
    + HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。
    + 用的端口也不一样，前者是80，后者是443
    + http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全

-   三次握手和四次挥手、为什么挥手需要四次

-   从游览器中输入URL到页面加载的发生了什么？可参考《*从输入URL到页面加载发生了什么*》

**2、数据存储和消息队列**
-------------------------

### **2.1、数据库**

-   MySQL 索引使用的注意事项

-   DDL、DML、DCL分别指什么

-   explain命令

-   left join，right join，inner join

-   数据库事物ACID（原子性、一致性、隔离性、持久性）

https://practice.geeksforgeeks.org/problems/acid-properties/
ACID属于DBMS中事务管理的概念，为了确保事务的正确性，下列的必须被保证的是:
原子性Atomicity: 事务是以原子的方式进行处理，要么全部完成或者没有产生影响。

-   事物的隔离级别（读未提交、读以提交、可重复读、可序列化读）

-   脏读、幻读、不可重复读

-   数据库的几大范式

-   数据库常见的命令

-   说说分库与分表设计

-   分库与分表带来的分布式困境与应对之策（如何解决分布式下的分库分表，全局表？）

-   说说 SQL 优化之道

-   MySQL遇到的死锁问题、如何排查与解决

-   存储引擎的 InnoDB与MyISAM区别，优缺点，使用场景
+ InnoDB
    + InnoDB 是 MySQL 默认的事务型存储引擎，InnoDB支持事务，MyISAM不支持。
    + InnoDB实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（next-key locking）防止幻影读。
    + 主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。
    + 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。
    + 支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。
    + InnoDB 支持外键,MySIAM不支持
+ MyISAM
    + MyISAM 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用 MyISAM。 
    + MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用。
    + MyISAM 提供了大量的特性，包括压缩表、空间数据索引等。
    + 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。
    + 如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。
    + InnoDB支持外键，MyISAM不支持

-   InnoDB的锁

InnoDB锁和事务模型：
https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html
关于IS, https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html



-   索引类别（B+树索引、全文索引、哈希索引）、索引的原理

-   什么是自适应哈希索引（AHI）

-   为什么要用 B+tree作为MySQL索引的数据结构

-   聚集索引与非聚集索引的区别

StackOverFlow
With a clustered index the rows are stored physically on the disk in the same order as the index. Therefore, there can be only one clustered index.
With a non clustered index there is a second list that has pointers to the physical rows. You can have many non clustered indexes, although each new index will increase the time it takes to write new records.
It is generally faster to read from a clustered index if you want to get back all the columns. You do not have to go first to the index and then to the table.
Writing to a table with a clustered index can be slower, if there is a need to rearrange the data.

https://www.jianshu.com/p/54c6d5db4fe6

-   遇到过索引失效的情况没，什么时候可能会出现，如何解决

-   limit 20000 加载很慢怎么解决

-   如何选择合适的分布式主键方案

-   选择合适的数据存储方案

-   常见的几种分布式ID的设计方案

    https://tech.meituan.com/MT_Leaf.html
    + UUID:
    优点：性能非常高：本地生成，没有网络消耗。
    缺点：
        + 不易于存储：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。
        + 信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。
        + ID作为主键时在特定的环境会存在一些问题，比如做DB主键的场景下，UUID就非常不适用，此时二级索引会占用很多空间
        + 对MySQL索引不利：如果作为数据库主键，在InnoDB引擎下，UUID的无序性可能会引起数据位置频繁变动，严重影响性能

    + 类snowflake方案：这种方案大致来说是一种以划分命名空间（UUID也算，由于比较常见，所以单独分析）来生成ID的一种算法，这种方案把64-bit分别划分成多段，分开来标示机器、时间等。如图：https://tech.meituan.com/img/leaf/image1.png
    优点: 
        + 毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。
        + 不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。
        + 可以根据自身业务特性分配bit位，非常灵活。
    缺点:
        + 强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。

    + 数据库生成: 以MySQL举例，利用给字段设置auto_increment_increment和auto_increment_offset来保证ID自增，每次业务使用下列SQL读写MySQL得到ID号。
    ```
    begin;
    REPLACE INTO Tickets64 (stub) VALUES ('a');
    SELECT LAST_INSERT_ID();
    commit;
    ```
    优点：
        + 非常简单，利用现有数据库系统的功能实现，成本小，有DBA专业维护。
        + ID号单调自增，可以实现一些对ID有特殊要求的业务。
    缺点:
        + 强依赖DB，当DB异常时整个系统不可用，属于致命问题。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。
        + ID发号性能瓶颈限制在单台MySQL的读写性能。
    对于MySQL性能问题，可用如下方案解决：在分布式系统中我们可以多部署几台机器，每台机器设置不同的初始值，且步长和机器数相等。也会带来问题，具体见文章。
    


-   常见的数据库优化方案，在你的项目中数据库如何进行优化的

### **2.2、Redis**

-   Redis 有哪些数据类型，可参考《*Redis常见的5种不同的数据类型详解*》

-   Redis 内部结构

-   Redis 使用场景

-   Redis 持久化机制，可参考《*使用快照和AOF将Redis数据持久化到硬盘中*》

-   Redis 集群方案与实现

-   Redis 为什么是单线程的？

-   缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级

    + 

-   使用缓存的合理性问题

-   Redis常见的回收策略

### **2.3、消息队列**

-   消息队列的使用场景
    + 异步处理：发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。
    + 应用解耦：在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。
    + 流量削峰：通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用。

-   消息的重发补偿解决思路

-   消息的幂等性解决思路
    + 使用消息存储方式，比如在接收方收到消息后，对Redis使用setnx id命令，结果为1表示第一次设置。
    + 唯一业务id

-   消息的堆积解决思路

-   自己如何实现消息队列

-   如何保证消息的有序性

**3、开源框架和容器**
---------------------

### **3.1、SSM/Servlet**

-   Servlet的生命周期

-   转发与重定向的区别

-   BeanFactory 和 ApplicationContext 有什么区别

-   Spring Bean 的生命周期

-   Spring IOC 如何实现

-   Spring中Bean的作用域，默认的是哪一个

-   说说 Spring AOP、Spring AOP 实现原理

-   动态代理（CGLib 与 JDK）、优缺点、性能对比、如何选择

-   Spring 事务实现方式、事务的传播机制、默认的事务类别

-   Spring 事务底层原理

-   Spring事务失效（事务嵌套），JDK动态代理给Spring事务埋下的坑，可参考《*JDK动态代理给Spring事务埋下的坑！*》

-   如何自定义注解实现功能

-   Spring MVC 运行流程

-   Spring MVC 启动流程

-   Spring 的单例实现原理

-   Spring 框架中用到了哪些设计模式

-   Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring
    Data、Spring AMQP 等）

-   有没有用到Spring Boot，Spring Boot的认识、原理

-   MyBatis的原理

-   可参考《[为什么会有Spring](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247484822&idx=1&sn=6fbee2a12b31b6102a18d3725671d41b&chksm=e9c5fc27deb275319641c3f30d168b85c7c196fd276d47efa35046b5dc54f5b77174c5bf8808&scene=21#wechat_redirect)》

-   可参考《[为什么会有Spring
    AOP](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247484827&idx=1&sn=b9d82f3fced6a875f8dfc22e5849b28e&chksm=e9c5fc2adeb2753c516ef8fc959c0c9dd84ccacaa40473b64bc58b5137c30562a0b45803ba8e&scene=21#wechat_redirect)》

### **3.2、Netty**

-   为什么选择 Netty

-   说说业务中，Netty 的使用场景

-   原生的 NIO 在 JDK 1.7 版本存在 epoll bug

-   什么是TCP 粘包/拆包

-   TCP粘包/拆包的解决办法

-   Netty 线程模型

-   说说 Netty 的零拷贝

-   Netty 内部执行流程

-   Netty 重连实现

**3.3、Tomcat**

-   Tomcat的基础架构（Server、Service、Connector、Container）

-   Tomcat如何加载Servlet的

-   Pipeline-Valve机制

-   可参考：《[四张图带你了解Tomcat系统架构](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247484905&idx=1&sn=6c8acd89476fadbc4cb9ccfda9c9c2e4&chksm=e9c5fc58deb2754e7519511bb0ed8dcbfa3fe29179663b53f3626643f8b9c82068d9b0464ee6&scene=21#wechat_redirect)*！*》

**4、分布式**
-------------

**4.1、Nginx**
--------------

-   请解释什么是C10K问题或者知道什么是C10K问题吗？

-   Nginx简介，可参考《*Nginx简介*》

-   正向代理和反向代理.

-   Nginx几种常见的负载均衡策略

-   Nginx服务器上的Master和Worker进程分别是什么

-   使用“反向代理服务器”的优点是什么?

### **4.2、分布式其他**

-   谈谈业务中使用分布式的场景

-   Session 分布式方案

-   Session 分布式处理

-   分布式锁的应用场景、分布式锁的产生原因、基本概念

-   分布是锁的常见解决方案

-   分布式事务的常见解决方案

-   集群与负载均衡的算法与实现

-   说说分库与分表设计，可参考《[数据库分库分表策略的具体实现方案](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247483931&idx=1&sn=6eda41aa81c1243422a603205d2fad22&chksm=e9c5fbaadeb272bc92537803c14a6f55e1170b1a3b8f60160f66417800c0ace960dfe192717a&scene=21#wechat_redirect)》

-   分库与分表带来的分布式困境与应对之策

**4.3、Dubbo**

-   什么是Dubbo，可参考《*Dubbo入门*》

-   什么是RPC、如何实现RPC、RPC 的实现原理，可参考《*基于HTTP的RPC实现*》

-   Dubbo中的SPI是什么概念

-   Dubbo的基本原理、执行流程

**5、微服务**
-------------

**5.1、微服务**

-   前后端分离是如何做的？

-   微服务哪些框架

-   Spring Could的常见组件有哪些？可参考《*Spring Cloud概述*》

-   领域驱动有了解吗？什么是领域驱动模型？充血模型、贫血模型

-   JWT有了解吗，什么是JWT，可参考《*前后端分离利器之JWT*》

-   你怎么理解 RESTful

-   说说如何设计一个良好的 API

-   如何理解 RESTful API 的幂等性

-   如何保证接口的幂等性

-   说说 CAP 定理、BASE 理论

-   怎么考虑数据一致性问题

-   说说最终一致性的实现方案

-   微服务的优缺点，可参考《[微服务批判](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247485005&idx=1&sn=78a1d286c6a15a81ea5dcf6634a70b54&chksm=e9c5fffcdeb276ea3c766a6e5954685db0e89bea8ff0f47c9a3ff2c0c02991f791a5160287c4&scene=21#wechat_redirect)》

-   微服务与 SOA 的区别

-   如何拆分服务、水平分割、垂直分割

-   如何应对微服务的链式调用异常

-   如何快速追踪与定位问题

-   如何保证微服务的安全、认证

### **5.2、安全问题**

-   如何防范常见的Web攻击、如何方式SQL注入

-   服务端通信安全攻防

-   HTTPS原理剖析、降级攻击、HTTP与HTTPS的对比

### **5.3、性能优化**

-   性能指标有哪些

-   如何发现性能瓶颈

-   性能调优的常见手段

-   说说你在项目中如何进行性能调优

**6、其他**
-----------

### **6.1、设计能力**

-   说说你在项目中使用过的UML图

-   你如何考虑组件化、服务化、系统拆分

-   秒杀场景如何设计

-   可参考：《[秒杀系统的技术挑战、应对策略以及架构设计总结一二！](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247485294&idx=1&sn=681b3fc8833bc978344f66c8dd33ff32&chksm=e9c5fedfdeb277c96e03e8943bff709ad5354cbbe0c0d894cdb9d1e8cc8da92bf51f1e832e37&scene=21#wechat_redirect)》

### **6.2、业务工程**

-   说说你的开发流程、如何进行自动化部署的

-   你和团队是如何沟通的

-   你如何进行代码评审

-   说说你对技术与业务的理解

-   说说你在项目中遇到感觉最难Bug，是如何解决的

-   介绍一下工作中的一个你认为最有价值的项目，以及在这个过程中的角色、解决的问题、你觉得你们项目还有哪些不足的地方

### **6.3、软实力**

-   说说你的优缺点、亮点

-   说说你最近在看什么书、什么博客、在研究什么新技术、再看那些开源项目的源代码

-   说说你觉得最有意义的技术书籍

-   工作之余做什么事情、平时是如何学习的，怎样提升自己的能力

-   说说个人发展方向方面的思考

-   说说你认为的服务端开发工程师应该具备哪些能力

-   说说你认为的架构师是什么样的，架构师主要做什么

-   如何看待加班的问题

二、Java面试通关秘籍第二套
==========================

**1、Java相关**
---------------

-   Arraylist与LinkedList默认空间是多少；

-   Arraylist与LinkedList区别与各自的优势List 和 Map 区别；

-   谈谈HashMap，哈希表解决hash冲突的方法；

-   为什么要重写hashcode()和equals()以及他们之间的区别与关系；

-   Object的hashcode()是怎么计算的？

-   若hashcode方法永远返回1或者一个常量会产生什么结果？

-   Java Collections和Arrays的sort方法默认的排序方法是什么；

-   引用计数法与GC Root可达性分析法区别；

-   浅拷贝和深拷贝的区别；

-   String s="abc"和String s=new String("abc")区别；

-   HashSet方法里面的hashcode存在哪，如果重写equals不重写hashcode会怎么样？

-   反射的作用与实现原理；

-   Java中的回调机制；

-   模板方法模式；

-   开闭原则说一下；

-   发布/订阅使用场景；

-   KMP算法（一种改进的字符串匹配算法）；

-   JMM里边的原子性、可见性、有序性是如何体现出来的，JMM中内存屏障是什么意思，

**2、多线程**
-------------

-   AtomicInteger底层实现原理；

-   synchronized与ReentraLock哪个是公平锁；

-   CAS机制会出现什么问题；

-   用过并发包下边的哪些类；

-   一个线程连着调用start两次会出现什么情况？

-   wait方法能不能被重写，wait能不能被中断；

-   线程池的实现？四种线程池？重要参数及原理？任务拒接策略有哪几种？

-   线程状态以及API怎么操作会发生这种转换；

-   常用的避免死锁方法；

**3、JVM**
----------

-   Minor GC与Full GC分别在什么时候发生？什么时候触发Full GC;

-   GC收集器有哪些？CMS收集器与G1收集器的特点。

-   Java在什么时候会出现内存泄漏；

-   Java中的大对象如何进行存储；

-   rt.jar被什么类加载器加载，什么时间加载；

-   自己写的类被什么加载，什么时间加载；

-   自己写的两个不同的类是被同一个类加载器加载的吗？为什么？

-   为什么新生代内存需要有两个Survivor区？

-   几种常用的内存调试工具：jmap、jstack、jconsole；

-   类加载的五个过程：加载、验证、准备、解析、初始化；

-   G1停顿吗，CMS回收步骤，CMS为什么会停顿，停顿时间；

-   栈主要存的数据是什么，堆呢？

-   堆分为哪几块，比如说新生代老生代，那么新生代又分为什么？

-   软引用和弱引用的使用场景（软引用可以实现缓存，弱引用可以用来在回调函数中防止内存泄露）；

**4、数据库**
-------------

-   数据库索引，什么是全文索引，全文索引中的倒排索引是什么原理

-   数据库最佳左前缀原则是什么？

-   数据库的三大范式；

-   悲观锁和乐观锁的原理和应用场景；

-   左连接、右连接、内连接、外连接、交叉连接、笛卡儿积等；

-   一般情况下数据库宕机了如何进行恢复（什么是Write Ahead Log机制，什么是Double
    Write机制，什么是Check Point）；

-   什么是redo日志、什么是undo日志；

-   数据库中的隔离性是怎样实现的；原子性、一致性、持久性又是如何实现的；

-   什么是组合索引，组合索引什么时候会失效；

-   关系型数据库和非关系型数据库区别；

-   数据库死锁如何解决；

-   MySQL并发情况下怎么解决（通过事务、隔离级别、锁）；

-   MySQL中的MVCC机制是什么意思，根据具体场景，MVCC是否有问题；

Mysql关于MVCC的文档:
InnoDB是一个多版本的存储引擎：它保存有关已更改行的旧版本的信息，以支持并发和回滚等事务功能。 此信息以称为回滚段的数据结构（在Oracle中的类似数据结构之后）存储在表空间中。 InnoDB使用回滚段中的信息来执行事务回滚中所需的撤消操作。 它还使用该信息构建行的早期版本以进行一致读取。
Undo Log: 除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC。


-   MySQL数据库的隔离级别，以及如何解决幻读；

**5、缓存服务器**
-----------------

-   Redis中zSet跳跃表问题；

-   Redis的set的应用场合？

-   Redis高级特性了解吗？

-   Redis的pipeline有什么用处？

-   Redis集群宕机如何处理，怎么样进行数据的迁移；

-   Redis的集群方案；

-   Redis原子操作怎么用比较好；

-   Redis过期策略是怎么实现的呢？

**6、SSM相关**
--------------

-   Spring中\@Autowired和\@Resource注解的区别？

-   Spring声明一个 bean 如何对其进行个性化定制；

-   MyBatis有什么优势；

-   MyBatis如何做事务管理；

**7、操作系统**
---------------

-   Linux静态链接和动态链接；

-   什么是IO多路复用模型（select、poll、epoll）；

-   Linux中的grep管道用处？Linux的常用命令？

-   操作系统中虚拟地址、逻辑地址、线性地址、物理地址的概念及区别；

-   内存的页面置换算法；

-   内存的页面置换算法；

-   进程调度算法，操作系统是如何调度进程的；

-   父子进程、孤儿进程、僵死进程等概念；

-   fork进程时的操作；

-   kill用法，某个进程杀不掉的原因（僵死进程；进入内核态，忽略kill信号）；

-   系统管理命令（如查看内存使用、网络情况）；

-   find命令、awk使用；

-   Linux下排查某个死循环的线程；

**8、网络相关**
---------------

-   数据链路层是做什么的?

-   数据链路层的流量控制？

-   网络模型的分层、IP和Mac地址在那个层、TCP和HTTP分别在那个层；

-   TCP滑动窗口；

-   TCP为什么可靠；

-   TCP的同传，拆包与组装包是什么意思；

-   Https和Http有什么区别；

-   Http 为什么是无状态的；

-   TCP三次握手，为什么不是三次，为什么不是四次；

-   TCP的拥塞控制、流量控制详细说明？

-   Http1.0和Http2.0的区别；

-   两个不同ip地址的计算机之间如何通信；

-   地址解析协议ARP；

-   OSI七层模型分别对应着五层模型的哪一部分；

-   TCP三次握手数据丢失了怎么办？那如果后面又找到了呢？

**9、分布式相关**
-----------------

-   消息队列使用的场景介绍和作用（应用耦合、异步消息、流量削锋等）；

-   如何解决消息队列丢失消息和重复消费问题；

-   Kafka使用过吗，什么是幂等性？怎么保证一致性，持久化怎么做，分区partition的理解，LEO是什么意思，如何保证多个partition之间数据一致性的（ISR机制），为什么Kafka可以这么快（基于磁盘的顺序读写）；

-   异步队列怎么实现；

-   你项目的并发是多少？怎么解决高并发问题？单机情况下Tomcat的并发大概是多少，MySQL的并发大致是多少？

-   什么是C10K问题；

-   高并发情况下怎么办；

-   分布式理论，什么是CAP理论，什么是Base理论，什么是Paxos理论；

CAP
它指出对于一个分布式计算系统来说，不可能同时满足以下三点:
    一致性（Consistence） （等同于所有节点访问同一份最新的数据副本）
    可用性（Availability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）
    分区容错性（Partition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择[3]。）

根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项[4]。理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。

Quora的解答：
The CAP theorem says that, fundamentally, there is a tension in asynchronous networks (those whose nodes do not have access to a **shared clock**) between three desirable properties of data store services distributed across more than one node:

    Availability - will a request made to the data store always eventually complete, no matter what (non-total) pattern of failures have occurred?
    Consistency - will all executions of reads and writes seen by all nodes be sequentially consistent? Roughly, this means that the results of 'earlier' writes are seen by 'later' reads, but the formal definition is a little more subtle.
    Partition tolerance - the network can suffer arbitrary failure patterns. This can be modelled as the refusal of the network to deliver any subset of the messages sent between nodes. Note that the failure of a single node can count as a 'partition'. See my blog post at [1] for more on this detail. 

Paxos算法：
https://www.cnblogs.com/linbingdong/p/6253479.html
Paxos算法分为两个阶段。具体如下：

    阶段一：

    (a) Proposer选择一个提案编号N，然后向半数以上的Acceptor发送编号为N的Prepare请求。

    (b) 如果一个Acceptor收到一个编号为N的Prepare请求，且N大于该Acceptor已经响应过的所有Prepare请求的编号，那么它就会将它已经接受过的编号最大的提案（如果有的话）作为响应反馈给Proposer，同时该Acceptor承诺不再接受任何编号小于N的提案。

    阶段二：

    (a) 如果Proposer收到半数以上Acceptor对其发出的编号为N的Prepare请求的响应，那么它就会发送一个针对[N,V]提案的Accept请求给半数以上的Acceptor。注意：V就是收到的响应中编号最大的提案的value，如果响应中不包含任何提案，那么V就由Proposer自己决定。

    (b) 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor没有对编号大于N的Prepare请求做出过响应，它就接受该提案。



-   分布式协议的选举算法；

-   说一下你对微服务的理解，与SOA的区别；

-   Dubbo的基本原理，RPC，支持哪些通信方式，服务的调用过程；

-   Dubbo如果有一个服务挂掉了怎么办；

-   分布式事务，操作两个表不在一个库，如何保证一致性。

-   分布式系统中，每台机器如何产生一个唯一的随机值；

-   系统的量级、pv、uv等；

-   什么是Hash一致性算法？分布式缓存的一致性，服务器如何扩容（哈希环）；

-   正向代理、反向代理；

-   什么是客户端负载均衡策略、什么是服务器端负载均衡策略；

-   如何优化Tomcat，常见的优化方式有哪些；

-   Nginx的Master和Worker，Nginx是如何处理请求的；

**10、系统设计相关**
--------------------

-   如何防止表单重复提交（Token令牌环等方式）；

-   有一个url白名单，需要使用正则表达式进行过滤，但是url量级很大，大概亿级，那么如何优化正则表达式？如何优化亿级的url匹配呢？

-   常见的Nginx负载均衡策略；已有两台Nginx服务器了，倘若这时候再增加一台服务器，采用什么负载均衡算法比较好？

-   扫描二维码登录的过程解析；

-   如何设计一个生成唯一UUID的算法？

-   实现一个负载均衡的算法，服务器资源分配为70%、20%、10%；

-   有三个线程T1 T2 T3，如何保证他们按顺序执行；

-   三个线程循环输出ABCABCABC....

**11、安全相关**
----------------

-   什么是XSS攻击，XSS攻击的一般表现形式有哪些？如何防止XSS攻击；

三、Java面试通关秘籍第三套
==========================

**1、基础题**
-------------

-   怎么解决Hash冲突；（开放地址法、链地址法、再哈希法、建立公共溢出区等）

-   写出一个必然会产生死锁的伪代码；

-   Spring IoC涉及到的设计模式；（工厂模式、单利模式。。）

-   toString()方法什么情况下需要重写；

-   判断对象相等时，什么情况下只需要重写 equals()，什么情况下需要重写
    equals(),hashcode()？

-   Set内存放的元素为什么不可以重复，内部是如何保证和实现的？

-   如何保证分布式缓存的一致性(分布式缓存一致性hash算法?)？分布式session实现？

-   Java 8流式迭代的好处？

-   项目中用到的JDK的哪些特性？

-   说一下TreeMap的实现原理？红黑树的性质？红黑树遍历方式有哪些？如果key冲突如何解决？setColor()方法在什么时候用？什么时候会进行旋转和颜色转换？

-   Spring的bean的创建时机？依赖注入的时机？

-   ArrayList和LinkList的删除一个元素的时间复杂度；（ArrayList是O(N)，LinkList是O(1)）；

-   CopyOnWriteArrayList是什么；

-   序列化和反序列化底层如何实现的（ObjectOutputStream 、ObjectInputStream、
    readObject  writeObject）；

-   如何调试多线程的程序；

-   一个线程连着调用start两次会出现什么情况？（由于状态只有就绪、阻塞、执行，状态是无法由执行转化为执行的，所以会报不合法的状态！）

-   HashMap在什么时候时间复杂度是O（1），什么时候是O（n），什么时候又是O（logn）；

-   wait方法能不能被重写？（wait是final类型的，不可以被重写，不仅如此，notify和notifyall都是final类型的），wait能不能被中断；

-   一个Controller调用两个Service，这两Service又都分别调用两个Dao，问其中用到了几个数据库连接池的连接？

**2、网络基础**
---------------

-   HTTP、TCP、UDP的区别和联系；

-   TCP和UDP各自的优势，知道哪些使用UDP协议的成功案例；

-   TCP和UDP各用了底层什么协议；

-   单个UDP报文最大容量；

-   单个TCP报文最大容量；

-   TCP报头格式、UDP报头格式；

-   Server遭遇SYN Flood应当怎么处理；

-   Web开发中如何防范XSS？

-   拆包和粘包的问题，如何解决，如果我们的包没有固定长度的话，我们的应用程序应该如何解决；

**3、操作系统**
---------------

-   为什么要内存对齐；

-   为什么会有大端小端，htol这一类函数的作用；

-   top显示出来的系统信息都是什么含义；（重要！）

-   Linux地址空间，怎么样进行寻址的；

-   Linux如何查找目录或者文件的；

**4、分布式其他**
-----------------

-   分库与分表带来的分布式困境与应对之策；

-   Solr如何实现全天24小时索引更新；

**5、Redis**
------------

-   Redis插槽的分配（key的有效部分使用CRC16算法计算出哈希值，再将哈希值对16384取余，得到插槽值）;

-   Redis主从是怎么选取的（一种是主动切换，另一种是使用sentinel自动方式）;

-   Redis复制的过程;

-   Redis队列应用场景；

-   Redis主节点宕机了怎么办，还有没有同步的数据怎么办;

**6、系统设计开放性题目**
-------------------------

-   秒杀系统设计，超卖怎么搞;

-   你们的图片时怎么存储的，对应在数据库中时如何保存图片的信息的？

-   假如成都没有一座消防站，现在问你要建立几座消防站，每个消防站要配多少名消防官兵，多少辆消防车，请你拿出一个方案；

-   基于数组实现一个循环阻塞队列；

-   常见的ipv4地址的展现形式如“168.0.0.1”，请实现ip地址和int类型的相互转换。（使用位移的方式）

-   现网某个服务部署在多台Liunx服务器上，其中一台突然出现CPU
    100%的情况，而其他服务器正常，请列举可能导致这种情况发生的原因？如果您遇到这样的情况，应如何定位？内存？CPU？发布？debug？请求量？

**7、大数据量问题（后边会有专题单独讨论）**
-------------------------------------------

-   给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？

-   海量日志数据，提取出某日访问百度次数最多的那个IP；

-   一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。

此话题后边会有专门的文章探讨，如果有等不及的小伙伴，可以移步参考：

1、https://blog.csdn.net/v_july_v/article/details/6279498

2、https://blog.csdn.net/v_july_v/article/details/7382693

**8、逻辑思维题**
-----------------

-   有两根粗细均匀的香（烧香拜佛的香），每一根烧完都花一个小时，怎么样能够得到15min？

-   假定你有8个撞球，其中有1个球比其他的球稍重,如果只能利用天平来断定哪一个球重,要找到较重的球,要称几次?（2次）；

-   实验室里有1000个一模一样的瓶子，但是其中的一瓶有毒。可以用实验室的小白鼠来测试哪一瓶是毒药。如果小白鼠喝掉毒药的话，会在一个星期的时候死去，其他瓶子里的药水没有任何副作用。请问最少用多少只小白鼠可以在一个星期以内查出哪瓶是毒药；（答案是10只）

-   假设有一个池塘，里面有无穷多的水。现有2个空水壶，容积分别为5升和6升。问题是如何只用这2个水壶从池塘里取得3升的水；

四、Java面试通关秘籍第四套
==========================

**1、Java基础**
---------------

-   为什么JVM调优经常会将-Xms和-Xmx参数设置成一样；

-   Java线程池的核心属性以及处理流程；

-   Java内存模型，方法区存什么；

-   CMS垃圾回收过程；

-   Full GC次数太多了，如何优化；

-   直接内存如何管理的；

-   Java线程池的几个参数的意义和实现机制；

-   Java线程池使用无界任务队列和有界任务队列的优劣对比；

-   CountDownLatch和CyclicBarrier的区别；

-   Java中有哪些同步方案（重量级锁、显式锁、并发容器、并发同步器、CAS、volatile、AQS等）

-   如果你的项目出现了内存泄露，怎么监控这个问题呢；

-   标记清除和标记整理的区别和优缺点，为何标记整理会发生stop the world；

-   线程池，如何根据CPU的核数来设计线程大小，如果是计算机密集型的呢，如果是IO密集型的呢？

-   让你设计一个cache如何设计；

-   String中hashcode是怎么实现的；

-   JDK中哪些实现了单例模式？

-   多个线程同时读写，读线程的数量远远⼤于写线程，你认为应该如何解决并发的问题？你会选择加什么样的锁？

-   线程池内的线程如果全部忙，提交⼀个新的任务，会发⽣什么？队列全部塞满了之后，还是忙，再提交会发⽣什么？

-   synchronized关键字锁住的是什么东西？在字节码中是怎么表示的？在内存中的对象上表现为什么？

-   wait/notify/notifyAll⽅法需不需要被包含在synchronized块中？这是为什么？

-   ExecutorService你一般是怎么⽤的？是每个Service放一个还是个项目放一个？有什么好处？

**2、数据库**
-------------

-   InnoDB的插入缓冲和两次写的概率和意义；

-   如果建了⼀个单列索引，查询的时候查出2列，会⽤到这个单列索引吗？（会用到）

-   如果建了⼀个包含多个列的索引，查询的时候只⽤了第⼀列，能不能⽤上这个索引？查三列呢？

-   接上题，如果where条件后⾯带有⼀个 i + 5 \< 100 会使⽤到这个索引吗？

-   like %aaa%会使⽤索引吗? like aaa%呢?

-   drop、truncate、delete的区别？

-   平时你们是怎么监控数据库的? 慢SQL是怎么排查的？（慢查询日志）

-   你们数据库是否⽀持emoji表情，如果不⽀持，如何操作?选择什么编码方式？如果支持一个表情占几个字节?(utf8mb4)；

-   如果查询很慢，你会想到的第⼀个⽅式是什么？（数据库索引）

**3、Linux基础**
----------------

-   Linux下可以在/proc目录下可以查看CPU的核心数等；cat
    /proc/下边会有很多系统内核信息可供显示； 

-   说一下栈的内存是怎么分配的；

-   Linux各个目录有了解过吗？/etc、/bin、/dev、/lib、/sbin这些常见的目录主要作用是什么？

-   说一下栈帧的内存是怎么分配的；

-   Linux下排查某个死循环的线程；

-   动态链接和静态链接的区别；

-   进程的内存分布；

-   如何查找一个进程打开所有的文件；

-   说一下常使用的协议及其对应的端口；

-   为什么会有内核态，保护模式你知道吗?

-   文件是怎么在磁盘上存储的？

-   有了进程为何还要线程呢，不同进程和线程他们之间有什么不同。（进程是资源管理的最小单位，线程是程序执行的最小单位。在操作系统设计上，从进程演化出线程，最主要的目的就是更好的支持SMP以及减小（进程/线程）上下文切换开销。）

-   InnoDB聚集索引B+树叶子节点和磁盘什么顺序相同;

-   文件系统，进程管理和调度，内存管理机制、虚地址保护模式；

**4、网络基础**
---------------

-   HTTP1.0和HTTP1.1的区别；

-   DHCP如何实现分配IP的； 发现阶段（DHCP客户端在网络中广播发送DHCP
    DISCOVER请求报文，发现DHCP服务器，请求IP地址租约）、提供阶段（DHCP服务器通过DHCP
    OFFER报文向DHCP客户端提供IP地址预分配）、选择阶段（DHCP客户端通过DHCP
    REQUEST报文确认选择第一个DHCP服务器为它提供IP地址自动分配服务）和确认阶段（被选择的DHCP服务器通过DHCP
    ACK报文把在DHCP OFFER报文中准备的IP地址租约给对应DHCP客户端）。

-   OSI七层模型，每层都说下自己的理解和知道的，说的越多越好；

**5、框架相关**
---------------

-   Servlet如何保证单例模式,可不可以编程多例的哪？

-   Dubbo请求流程以及原理；

-   Spring框架如何实现事务的；

-   如果一个接⼝有2个不同的实现,
    那么怎么来Autowire一个指定的实现？(可以使用Qualifier注解限定要注入的Bean，也可以使用Qualifier和Autowire注解指定要获取的bean，也可以使用Resource注解的name属性指定要获取的Bean)

-   Spring框架中需要引用哪些jar包，以及这些jar包的用途；

-   Spring Boot没有放到web容器⾥为什么能跑HTTP服务？

-   Spring中循环注入是什么意思，可不可以解决，如何解决；

-   Spring的声明式事务 \@Transaction注解⼀般写在什么位置?
    抛出了异常会⾃动回滚吗？有没有办法控制不触发回滚?

-   MyBatis怎么防止SQL注入；

-   Tomcat本身的参数你⼀般会怎么调整？

-   了解哪几种序列化协议？如何选择合适的序列化协议；

-   Redis渐进式rehash过程？

-   比如我有个电商平台，做每日订单的异常检测，服务端代码应该写；

五、Java面试通关秘籍第五套
==========================

**1、Java相关**
---------------

-   乐观悲观锁的设计，如何保证原子性，解决的问题；

-   char和double的字节，以及在内存的分布是怎样；

-   对象内存布局，然后讲下对象的死亡过程？

-   对象头，详细讲下；

-   sync原理详细，sync内抛异常会怎样，死锁吗？还是释放掉？怎么排查死锁？死锁会怎样？有没有什么更好的替代方案？

-   详细讲一下集合，HashSet源码，HashMap源码，如果要线程安全需要怎么做？

-   多线程是解决什么问题的？线程池解决什么问题？

-   线程池，如何设计的，里面的参数有多少种，里面的工作队列和线程队列是怎样的结构，如果给你，怎样设计线程池？

-   AQS原理，ReentranLock源码，设计原理，整体过程。

-   继续聊多线程源码，sync原理，然后一个场景设计题；

-   float f = 1.4f;double d = 1.4d; 与 float f = 1.5f;double d = 1.5d;
    是否为true，内存是怎样的；

-   split的源码，split("a\|b\|c");得出多少个数组；

-   把所有认识熟用的JUC(
    java.util.concurrent(简称JUC)包)下的类写出来，讲下使用，然后讲下原生的线程操作;

-   开闭原则，解析工厂方法模式，建造者模式，区别。手撸出来。

-   讲下JVM的大页模式，JVM内存模型;

-   什么是敏捷开发，防御性编程，并行编程。Team Leader的思考;

-   逃逸分析是什么，作用是什么，用途是什么;

有两个地方会导致Java中new出来的对象并一定分别在所认为的堆上。这两个点分别是Java中的逃逸分析和TLAB（Thread Local Allocation Buffer）。
逃逸分析，是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。 
在计算机语言编译器优化原理中，逃逸分析是指分析指针动态范围的方法，它同编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他过程或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。
Java的 HotSpot JIT编译器，能够在方法重载或者动态加载代码的时候对代码进行逃逸分析，同时Java对象在堆上分配和内置线程的特点使得逃逸分析成Java的重要功能。
算法引入了连通图，用连通图来构建对象和对象引用之间的可达性关系，并在次基础上，提出一种组合数据流分析法。
经过逃逸分析之后，可以得到三种对象的逃逸状态。
+ GlobalEscape（全局逃逸: 即一个对象的引用逃出了方法或者线程。例如，一个对象的引用是复制给了一个类变量，或者存储在在一个已经逃逸的对象当中，或者这个对象的引用作为方法的返回值返回给了调用方法。
+ ArgEscape（参数级逃逸）: 即在方法调用过程当中传递对象的应用给一个方法。
+ oEscape（没有逃逸）: 一个可以进行标量替换的对象。可以不将这种对象分配在传统的堆上。
编译器可以使用逃逸分析的结果，对程序进行一下**优化**。
+ 堆分配对象变成栈分配对象。一个方法当中的对象，对象的引用没有发生逃逸，那么这个方法可能会被分配在栈内存上而非常见的堆内存上。
+ 消除同步。线程同步的代价是相当高的，同步的后果是降低并发性和性能。逃逸分析可以判断出某个对象是否始终只被一个线程访问，如果只被一个线程访问，那么对该对象的同步操作就可以转化成没有同步保护的操作，这样就能大大提高并发程度和性能。
+ 矢量替代。逃逸分析方法如果发现对象的内存存储结构不需要连续进行的话，就可以将对象的部分甚至全部都保存在CPU寄存器内，这样能大大提高访问速度。
```
-server -verbose:gc         未开启逃逸分析设置
-server -verbose:gc -XX:+DoEscapeAnalysis  开启逃逸分析设置
```

-   怎么认为一个类是线程安全？线程安全的定义是什么？Java有多少个关键字进行同步？为什么这样设计？（聊了一大堆，一堆为什么）；

-   两个线程设计题。记得一个是：t1,t2,t3，让t1，t2执行完才执行t3，原生实现。

-   写个后缀表达式，为什么要设计后缀表达式，有什么好处？然后写下中缀。

-   我看你做过性能优化，比如你怎么分析项目里面的OOM的，内存泄露呢？详细说思路;

-   说下多线程，我们什么时候需要分析线程数，怎么分析，分析什么因素;

-   抽象方法和类方法的区别，static的抽象方法可以吗？

-   说下Java的克隆体系;

-   涉及OOM、JVM优化、源码问题、数据库优化、多线程等问题;

-   CPU高？什么情况CPU高？解决什么问题？

-   你有遇到过临界区问题吗？有遇到过吗？你在项目遇到这个问题是怎样解决的？

-   volatile关键字作用;

-   Java的多态怎么实现;

-   解释一下自旋;

-   解释一下信号量;

-   什么情况下会触发类加载；

-   Java内存抖动严重，优化的思路；

**2、数据库相关**
-----------------

-   SQL优化思路，联合索引与底层树结构的映像关系，索引结构（B+、B-），为什么用这样的结构；

-   讲下MySQL的集群？集群遇到过什么问题？sql的优化？

-   你目前为止遇到的最大数据量是多少？知道100万时候怎么设计吗？1000万呢？过几十亿呢？

-   MySQL有多少个参数可调，除了最大连接数。全部列出来，一个个分析。

-   聊下优化过的索引，怎么优化;

-   红黑树和平衡树的区别，为什么数据库不用红黑树;

-   mysql有哪些锁，意向锁有什么用;

-   数据库高并发下的优化思路;

-   数据库什么情况下索引会失效;

**3、数据结构和操作系统相关**
-----------------------------

-   数据结构学过吧，聊一下？学过什么结构？讲下树和队列？B树呢？

-   操作系统学过吧，聊一下？讲一下系统内存是怎样的？分段分页虚拟内存？

-   页面置换算法呢？多少种？有最优的置换算法吗？

-   你学过什么课程？然后聊下操作系统，内核、用户之类。

-   反转链表手撸;

-   快排，给一串数组，把具体每次patition写下，最终结果也写45, 32, 41, 35, 38,
    20, 50;

-   一个整数status, 判断第K个比特位是否为比特1;

-   把递归实现的快排改成非递归，你知道非递归有什么好处吗;

-   举例使用分治思想的算法;

**4、网络相关**
---------------

-   讲下请求头细节？

-   Http和Https？Http1.0,1.1,2.0，讲下长连接和短连接？Https是怎样的？如果我篡改了公钥呢？怎么防止？

-   Get和Post，讲下区别，要我模拟出抓包来。

-   详细讲下Cookie和Session，Token，OAuth2.0协议;

-   拥塞算法知道吗？哪些，分别怎样？

-   学过计算机网络是吧？socket熟悉吗？对它的读写缓冲区有理解吗？怎么的？那滑动窗口是怎样的？为什么这样设计？

-   再聊下Http的Http basic authentication;

-   Https的过程;

**5、框架相关**
---------------

-   聊下Spring源码，知道多少，都聊一下；

-   聊下Spring注解，\@Autowire，\@Resource，以及他们的解析过程；

-   聊一下架构，接入层架构，服务层架构。聊下技术栈，Spring Boot，Spring
    Cloud、Docker；

-   Spring ioc的具体优势，和直接New一个对象有什么区别;

-   Servlet生命周期，是否单例，为什么是单例;

-   Spring Mvc初始化过程；

**6、分布式相关**
-----------------

-   多少种RPC框架？

-   一致性哈希是干嘛的？

-   搭建高并发高可用系统需要怎样设计？考虑哪些东西，有多少说多少。

-   你对缓存有什么理解？缓存是解决什么问题？后端缓存有哪些，分别解决什么问题？

-   聊一下分布式锁；

-   你是怎么设计系统缓存的，为什么，什么场景；

-   也来说下，削峰的多种实现，Redis？MQ？

-   为什么用mq就能削峰？解决什么问题？

**7、设计题**
-------------

-   有几台机器存储着几亿淘宝搜索日志，你只有一台2g的电脑，怎么选出搜索热度最高的十个搜索关键词;

-   如何设计算法压缩一段URL;

-   有一个页面能同时展示两个广告，现在有五个广告，设计算法使五个广告展示概率为1:2:3:4:5；

-   有25匹马，五个赛道，用最少比赛次数将25匹马排序；

**8、其他相关**
---------------

-   Tomcat缓存，聊下缓存的整体理解，知道多少种缓存；

-   解释下Mucene原理，倒排索引，怎样进行中文分词，基于什么进行分词；

-   TopN的大数据量题；

-   你对接入层要思考什么东西？遇到过哪些问题？搭建系统要考量哪些因素？

-   然后项目问题，优化问题；

-   熟悉maven是吧？我们来聊下Maven的源码原理，Maven冲突的时候，怎么选择依赖包，我们怎么查，我们遇到两个不一样的版本，我们应该如何去选择，为什么？

-   项目如何分组，性能优化小组应该做哪些;

-   我们来说下接入层的搭建，认知分析;

-   问下项目的系统构建，思考，为什么这样构建？

-   如何判断一段代码的好坏;
